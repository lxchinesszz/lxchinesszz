import{_ as e,o as a,c as l,a4 as n}from"./chunks/framework.B8fosacB.js";const f=JSON.parse('{"title":"MVCC机制","description":"","frontmatter":{"breadcrumb":false,"navbar":true,"sidebar":true,"pageInfo":true,"contributor":true,"editLink":true,"updateTime":true,"prev":true,"next":true,"comment":false,"footer":true,"backtotop":true,"title":"MVCC机制","category":"SQL优化"},"headers":[],"relativePath":"post/java/sql/MVCC.md","filePath":"post/java/sql/MVCC.md","lastUpdated":1731158524000}'),s={name:"post/java/sql/MVCC.md"};function i(r,t,d,p,o,c){return a(),l("div",{"data-pagefind-body":!0},t[0]||(t[0]=[n(`<p><img src="https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png" alt=""></p><p><strong>作者</strong>: 西魏陶渊明 <strong>博客</strong>: <a href="https://blog.springlearn.cn/" target="_blank" rel="noreferrer">https://blog.springlearn.cn/</a></p><div class="tip custom-block"><p class="custom-block-title">西魏陶渊明</p><p>莫笑少年江湖梦，谁不少年梦江湖</p></div><h3 id="什么是mvcc" tabindex="-1">什么是MVCC? <a class="header-anchor" href="#什么是mvcc" aria-label="Permalink to &quot;什么是MVCC?&quot;">​</a></h3><p>Multi-Version Concurrency Control 多版本并发控制，MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。</p><p>mvcc机制主要是用来解决并发情况下访问,维护数据的隔离性原则。</p><h3 id="举例子" tabindex="-1">举例子 <a class="header-anchor" href="#举例子" aria-label="Permalink to &quot;举例子&quot;">​</a></h3><p>有两个字段</p><table><thead><tr><th style="text-align:left;">字段</th><th style="text-align:left;">值</th><th style="text-align:left;">备注</th></tr></thead><tbody><tr><td style="text-align:left;">name</td><td style="text-align:left;">沙悟净</td><td style="text-align:left;">原始数据</td></tr><tr><td style="text-align:left;">name</td><td style="text-align:left;">孙悟空</td><td style="text-align:left;">事务1,已提交数据</td></tr><tr><td style="text-align:left;">name</td><td style="text-align:left;">唐三藏</td><td style="text-align:left;">事务2,未提交</td></tr><tr><td style="text-align:left;">name</td><td style="text-align:left;">猪八戒</td><td style="text-align:left;">事务3,未提交</td></tr></tbody></table><p>因为我们知道事务具有隔离性，所以下面我们出几个问题。</p><ol><li>此时有一个事务4来了,看到的name是多少? 【孙悟空】</li><li>事务1,以更新已提交,看到的name是多少?【孙悟空】</li><li>事务2,以更新但是未提交,看到的name是多少? 【唐三藏】</li><li>事务3,以更新但是未提交,看到的name是多少?【猪八戒】</li></ol><p>看到了吗? 上面每个事务可能看到的东西不一样, 为啥不一样,因为隔离性。 那么我们思考一个问题,数据库表中,只会有一份数据,mysql是如何实现的隔离性, 让每个事务看到的东西还不一样呢? 如果让你来做,你怎么来实现呢?</p><h3 id="实现原理" tabindex="-1">实现原理 <a class="header-anchor" href="#实现原理" aria-label="Permalink to &quot;实现原理&quot;">​</a></h3><p>只使用数据库表中的数据是完全不行的,因为能落表中的数据,已经是最后一个事务提交后的数据。 要想实现多版本控制必须, 有一个地方能记录每个事务的改动。</p><p>那么在mysql中是怎么记录的呢? <code>undo log</code></p><p>对于上面的例子,在 <code>undo log</code> 中是这样记录的。</p><table><thead><tr><th style="text-align:left;">事务id</th><th style="text-align:left;">变动值</th><th style="text-align:left;">状态</th></tr></thead><tbody><tr><td style="text-align:left;">事务1</td><td style="text-align:left;">孙悟空</td><td style="text-align:left;">已提交</td></tr><tr><td style="text-align:left;">事务2</td><td style="text-align:left;">唐三藏</td><td style="text-align:left;">未提交</td></tr><tr><td style="text-align:left;">事务3</td><td style="text-align:left;">猪八戒</td><td style="text-align:left;">未提交</td></tr></tbody></table><ul><li>m_ids 当前所有活跃的事务,即未提交的事务</li><li>min_trx_id 最早的事务</li><li>max_trx_id 最大的事务,下一个要生成的事务id就是最大事务</li><li>creator_trx_id 当前select创建的read view事务id</li></ul><p>m_ids = [事务3,事务2] min_trx_id = [事务2] max_trx_id = [事务4] creator_trx_id = trx_id = [事务4]</p><table><thead><tr><th style="text-align:left;">事务id</th><th style="text-align:left;">变动值</th><th style="text-align:left;">状态</th></tr></thead><tbody><tr><td style="text-align:left;">事务2</td><td style="text-align:left;">唐三藏</td><td style="text-align:left;">未提交</td></tr><tr><td style="text-align:left;">事务3</td><td style="text-align:left;">猪八戒</td><td style="text-align:left;">未提交</td></tr></tbody></table><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>    for(row in rows){</span></span>
<span class="line"><span>        if(creator_trx_id === trx_id){</span></span>
<span class="line"><span>            // 自己的事务,那么能直接看到这一行数据。</span></span>
<span class="line"><span>            // 这个时候不用管自己的事务，是不是最后一个事务,因为隔离性我们只能读到在我们前已提交或者是自己的未提交的数据</span></span>
<span class="line"><span>         }else if(&#39;自己的事务id&#39; &lt; min_trx_id){</span></span>
<span class="line"><span>            // 以为当前事务创建前, 最早的事务已经更新了,只是未提交,但是根据mysql默认的隔离机制</span></span>
<span class="line"><span>            // 可重复读,以为他能读取</span></span>
<span class="line"><span>         }</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>默认沙悟净,事务2,更新后不提交,相同事务下,事务2看到的就是自己修改后的唐三藏。 <img src="https://img.springlearn.cn/blog/66f3d6343322b2c6d571df02c10863f7.png" alt=""></p><p>此时在用线程3先查询下,已经只能看到已提交的,所以看的还是原来的沙悟净。 <img src="https://img.springlearn.cn/blog/d413b719a18f60288aeb2429751efb30.png" alt=""></p>`,23)]))}const b=e(s,[["render",i]]);export{f as __pageData,b as default};
