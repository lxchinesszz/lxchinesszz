import{_ as e,o as s,c as n,a4 as r}from"./chunks/framework.B8fosacB.js";const b=JSON.parse('{"title":"SQL索引性能优化","description":"","frontmatter":{"breadcrumb":false,"navbar":true,"sidebar":true,"pageInfo":true,"contributor":true,"editLink":true,"updateTime":true,"prev":true,"next":true,"comment":false,"footer":true,"backtotop":true,"title":"SQL索引性能优化"},"headers":[],"relativePath":"post/java/sql/SQL索引性能优化.md","filePath":"post/java/sql/SQL索引性能优化.md","lastUpdated":1731158524000}'),l={name:"post/java/sql/SQL索引性能优化.md"};function t(o,a,i,p,c,u){return s(),n("div",{"data-pagefind-body":!0},a[0]||(a[0]=[r('<p><img src="https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png" alt=""></p><p><strong>作者</strong>: 西魏陶渊明 <strong>博客</strong>: <a href="https://blog.springlearn.cn/" target="_blank" rel="noreferrer">https://blog.springlearn.cn/</a></p><div class="tip custom-block"><p class="custom-block-title">西魏陶渊明</p><p>莫笑少年江湖梦，谁不少年梦江湖</p></div><h1 id="建表" tabindex="-1">建表 <a class="header-anchor" href="#建表" aria-label="Permalink to &quot;建表&quot;">​</a></h1><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 建表</span></span>\n<span class="line"><span>CREATE TABLE IF NOT EXISTS staffs(</span></span>\n<span class="line"><span>    id INT PRIMARY KEY AUTO_INCREMENT,</span></span>\n<span class="line"><span>    name VARCHAR(24) NOT NULL DEFAULT &quot;&quot; COMMENT&#39;姓名&#39;,</span></span>\n<span class="line"><span>    age INT NOT NULL DEFAULT 0 COMMENT&#39;年龄&#39;,</span></span>\n<span class="line"><span>    pos VARCHAR(20) NOT NULL DEFAULT &quot;&quot; COMMENT&#39;职位&#39;,</span></span>\n<span class="line"><span>    add_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT&#39;入职事件&#39;</span></span>\n<span class="line"><span>) CHARSET utf8 COMMENT&#39;员工记录表&#39;;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 插入数据</span></span>\n<span class="line"><span>INSERT INTO `test`.`staffs` (`name`, `age`, `pos`, `add_time`) VALUES (&#39;z3&#39;, 22, &#39;manager&#39;, now());</span></span>\n<span class="line"><span>INSERT INTO `test`.`staffs` (`name`, `age`, `pos`, `add_time`) VALUES (&#39;July&#39;, 23, &#39;dev&#39;, now());</span></span>\n<span class="line"><span>INSERT INTO `test`.`staffs` (`name`, `age`, `pos`, `add_time`) VALUES (&#39;2000&#39;, 23, &#39;dev&#39;, now());</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 建立复合索引（即一个索引包含多个字段）</span></span>\n<span class="line"><span>ALTER TABLE staffs ADD INDEX idx_staffs_nameAgePos(name, age, pos);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><hr><h2 id="优化一、全部用到索引" tabindex="-1">优化一、全部用到索引 <a class="header-anchor" href="#优化一、全部用到索引" aria-label="Permalink to &quot;优化一、全部用到索引&quot;">​</a></h2><h3 id="_1-介绍" tabindex="-1">1. 介绍 <a class="header-anchor" href="#_1-介绍" aria-label="Permalink to &quot;1. 介绍&quot;">​</a></h3><p>建立的复合索引包含了几个字段，查询的时候最好能全部用到，而且严格按照索引顺序，这样查询效率是最高的。（最理想情况，具体情况具体分析）</p><h3 id="_2-sql案例" tabindex="-1">2. SQL案例 <a class="header-anchor" href="#_2-sql案例" aria-label="Permalink to &quot;2. SQL案例&quot;">​</a></h3><p><img src="https://img.springlearn.cn/blog/learn_1596353647000.png" alt=""></p><h2 id="优化二、最左前缀法则" tabindex="-1">优化二、最左前缀法则 <a class="header-anchor" href="#优化二、最左前缀法则" aria-label="Permalink to &quot;优化二、最左前缀法则&quot;">​</a></h2><h3 id="_1-介绍-1" tabindex="-1">1. 介绍 <a class="header-anchor" href="#_1-介绍-1" aria-label="Permalink to &quot;1. 介绍&quot;">​</a></h3><p>如果建立的是复合索引，索引的顺序要按照建立时的顺序，即从左到右，如：a-&gt;b-&gt;c（和 B+树的数据结构有关）</p><h3 id="_2-无效索引举例" tabindex="-1">2. 无效索引举例 <a class="header-anchor" href="#_2-无效索引举例" aria-label="Permalink to &quot;2. 无效索引举例&quot;">​</a></h3><p>如果用了a和c,那么a索引有效,c无效,因为中间跳过了b</p><p>如果用了b和c,那么b索引和c索引都无效,因为跳过了a</p><p>如果只用了c,那么也会无效,因为跳过了a和b</p><p><img src="https://img.springlearn.cn/blog/learn_1596354258000.png" alt=""></p><h2 id="优化三、不要对索引做以下处理" tabindex="-1">优化三、不要对索引做以下处理 <a class="header-anchor" href="#优化三、不要对索引做以下处理" aria-label="Permalink to &quot;优化三、不要对索引做以下处理&quot;">​</a></h2><h3 id="_1-以下用法会导致索引失效" tabindex="-1">1. 以下用法会导致索引失效 <a class="header-anchor" href="#_1-以下用法会导致索引失效" aria-label="Permalink to &quot;1. 以下用法会导致索引失效&quot;">​</a></h3><ul><li>计算，如：+、-、*、/、!=、&lt;&gt;、is null、is not null、or</li><li>函数，如：sum()、round()等等</li><li>手动/自动类型转换，如：id = &quot;1&quot;，本来是数字，给写成字符串了</li></ul><p><img src="https://img.springlearn.cn/blog/learn_1596354578000.png" alt=""></p><h2 id="优化四、索引不要放在范围查询右边" tabindex="-1">优化四、索引不要放在范围查询右边 <a class="header-anchor" href="#优化四、索引不要放在范围查询右边" aria-label="Permalink to &quot;优化四、索引不要放在范围查询右边&quot;">​</a></h2><h3 id="_1-举例" tabindex="-1">1. 举例 <a class="header-anchor" href="#_1-举例" aria-label="Permalink to &quot;1. 举例&quot;">​</a></h3><p>比如复合索引：a-&gt;b-&gt;c，当 where a=&quot;&quot; and b&gt;10 and 3=&quot;&quot;，这时候只能用到 a 和 b，c 用不到索引，因为在范围之后索引都失效（和 B+树结构有关）</p><p>因为b使用了范围,所以右边的索引c就失效了</p><p><img src="https://img.springlearn.cn/blog/learn_1596355600000.png" alt=""></p><h2 id="优化五、减少-select-的使用" tabindex="-1">优化五、减少 select * 的使用 <a class="header-anchor" href="#优化五、减少-select-的使用" aria-label="Permalink to &quot;优化五、减少 select \\* 的使用&quot;">​</a></h2><h3 id="_1-使用覆盖索引" tabindex="-1">1. 使用覆盖索引 <a class="header-anchor" href="#_1-使用覆盖索引" aria-label="Permalink to &quot;1. 使用覆盖索引&quot;">​</a></h3><p>即：select 查询字段和 where 中使用的索引字段一致。</p><p><img src="https://img.springlearn.cn/blog/learn_1596355952000.png" alt=""></p><h2 id="优化六、like-模糊搜索" tabindex="-1">优化六、like 模糊搜索 <a class="header-anchor" href="#优化六、like-模糊搜索" aria-label="Permalink to &quot;优化六、like 模糊搜索&quot;">​</a></h2><h3 id="_1-失效情况" tabindex="-1">1. 失效情况 <a class="header-anchor" href="#_1-失效情况" aria-label="Permalink to &quot;1. 失效情况&quot;">​</a></h3><p>like &quot;%张三%&quot; like &quot;%张三&quot;</p><h3 id="_2-解决方案" tabindex="-1">2. 解决方案 <a class="header-anchor" href="#_2-解决方案" aria-label="Permalink to &quot;2. 解决方案&quot;">​</a></h3><ul><li><p>使用复合索引，即 like 字段是 select 的查询字段，如：select name from table where name like &quot;%张三%&quot; 使用 like &quot;张三%&quot;</p></li><li><p>使用 like &quot;张三%&quot;</p></li></ul><h2 id="优化七、order-by-优化" tabindex="-1">优化七、order by 优化 <a class="header-anchor" href="#优化七、order-by-优化" aria-label="Permalink to &quot;优化七、order by 优化&quot;">​</a></h2><p>当查询语句中使用 order by 进行排序时，如果没有使用索引进行排序，会出现 filesort 文件内排序，这种情况在数据量大或者并发高的时候，会有性能问题，需要优化。</p><h3 id="_1-filesort-出现的情况举例" tabindex="-1">1. filesort 出现的情况举例 <a class="header-anchor" href="#_1-filesort-出现的情况举例" aria-label="Permalink to &quot;1. filesort 出现的情况举例&quot;">​</a></h3><ul><li>order by 字段不是索引字段</li><li>order by 字段是索引字段，但是 select 中没有使用覆盖索引，如：<code>select * from staffs order by age asc;</code></li><li>order by 中同时存在 ASC 升序排序和 DESC 降序排序，如：<code>select a, b from staffs order by a desc, b asc;</code></li><li>order by 多个字段排序时，不是按照索引顺序进行 order by，即不是按照最左前缀法则，如：<code>select a, b from staffs order by b asc, a asc;</code></li></ul><h3 id="_2-索引层面解决方法" tabindex="-1">2. 索引层面解决方法 <a class="header-anchor" href="#_2-索引层面解决方法" aria-label="Permalink to &quot;2. 索引层面解决方法&quot;">​</a></h3><ul><li>使用主键索引排序</li><li>按照最左前缀法则，并且使用覆盖索引排序，多个字段排序时，保持排序方向一致</li><li>在 SQL 语句中强制指定使用某索引，force index(索引名字)</li><li>不在数据库中排序，在代码层面排序</li></ul><h3 id="_3-order-by-排序算法" tabindex="-1">3. order by 排序算法 <a class="header-anchor" href="#_3-order-by-排序算法" aria-label="Permalink to &quot;3. order by 排序算法&quot;">​</a></h3><p><strong>双路排序</strong></p><p><em>Mysql4.1 之前是使用双路排序，字面的意思就是两次扫描磁盘，最终得到数据，读取行指针和 ORDER BY 列，对他们进行排序，然后扫描已经排好序的列表，按照列表中的值重新从列表中读取对数据输出。也就是从磁盘读取排序字段，在 buffer 进行排序，再从磁盘读取其他字段。</em></p><p>文件的磁盘 IO 非常耗时的，所以在 Mysql4.1 之后，出现了第二种算法，就是单路排序。</p><p><em>从磁盘读取查询需要的所有列，按照 orderby 列在 buffer 对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据，并且把随机 IO 变成顺序 IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</em></p><p>当我们无可避免要使用排序时，索引层面没法在优化的时候又该怎么办呢？尽可能让 MySQL 选择使用第二种单路算法来进行排序。这样可以减少大量的随机 IO 操作,很大幅度地提高排序工作的效率。下面看看单路排序优化需要注意的点</p><p><strong>单路排序优化点</strong></p><p>增大 max_length_for_sort_data</p><p><em>在 MySQL 中,决定使用&quot;双路排序&quot;算法还是&quot;单路排序&quot;算法是通过参数 maxlength_for sort_data 来决定的。当所有返回字段的最大长度小于这个参数值时,MySQL 就会选择&quot;单路排序&quot;算法,反之,则选择&quot;多路排序&quot;算法。所以,如果有充足的内存让 MySQL 存放须要返回的非排序字段,就可以加大这个参数的值来让 MySQL 选择使用&quot;单路排序&quot;算法。</em></p><p>去掉不必要的返回字段，避免select *</p><p><em>当内存不是很充裕时,不能简单地通过强行加大上面的参数来强迫 MySQL 去使用&quot;单路排序&quot;算法,否则可能会造成 MySQL 不得不将数据分成很多段,然后进行排序,这样可能会得不偿失。此时就须要去掉不必要的返回字段,让返回结果长度适应 max_length_for_sort_data 参数的限制。</em></p><p>增大 sort_buffer_size 参数设置</p><p><em>这个值如果过小的话,再加上你一次返回的条数过多,那么很可能就会分很多次进行排序,然后最后将每次的排序结果再串联起来,这样就会更慢,增大 sort_buffer_size 并不是为了让 MySQL 选择&quot;单路排序&quot;算法,而是为了让 MySQL 尽量减少在排序过程中对须要排序的数据进行分段,因为分段会造成 MySQL 不得不使用临时表来进行交换排序。</em></p><p>但是sort_buffer_size 不是越大越好：</p><ul><li>Sort_Buffer_Size 是一个 connection 级参数,在每个 connection 第一次需要使用这个 buffer 的时候,一次性分配设置的内存。</li><li>Sort_Buffer_Size 并不是越大越好,由于是 connection 级的参数,过大的设置和高并发可能会耗尽系统内存资源。</li><li>据说 Sort_Buffer_Size 超过 2M 的时候,就会使用 mmap() 而不是 malloc() 来进行内存分配,导致效率降低。</li></ul><h2 id="优化八、group-by" tabindex="-1">优化八、group by <a class="header-anchor" href="#优化八、group-by" aria-label="Permalink to &quot;优化八、group by&quot;">​</a></h2><p>其原理也是先排序后分组，其优化方式可参考order by。where高于having,能写在where限定的条件就不要去having限定了。</p>',60)]))}const h=e(l,[["render",t]]);export{b as __pageData,h as default};
