import{_ as s,c as n,aa as e,o as l}from"./chunks/framework.swcE7GHT.js";const u=JSON.parse('{"title":"委派双亲之类加载器","description":"","frontmatter":{"breadcrumb":false,"navbar":true,"sidebar":true,"pageInfo":true,"contributor":true,"editLink":true,"updateTime":true,"prev":true,"next":true,"comment":false,"footer":true,"backtotop":true,"title":"委派双亲之类加载器","category":"Java进阶"},"headers":[],"relativePath":"java/委派双亲之类加载器.md","filePath":"java/委派双亲之类加载器.md"}'),p={name:"java/委派双亲之类加载器.md"};function r(t,a,i,o,c,d){return l(),n("div",null,a[0]||(a[0]=[e(`<p><img src="https://img.springlearn.cn/blog/learn_1589811713000.png" alt=""></p><p><strong>作者</strong>: 西魏陶渊明 <strong>博客</strong>: <a href="https://blog.springlearn.cn/" target="_blank" rel="noreferrer">https://blog.springlearn.cn/</a></p><div class="tip custom-block"><p class="custom-block-title">西魏陶渊明</p><p>莫笑少年江湖梦，谁不少年梦江湖</p></div><ul><li>BootStrap ClassLoader：称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件：</li><li>Extension ClassLoader：称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。</li><li>App ClassLoader：称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。</li></ul><h2 id="一、类加载器" tabindex="-1">一、类加载器 <a class="header-anchor" href="#一、类加载器" aria-label="Permalink to &quot;一、类加载器&quot;">​</a></h2><p>类的加载在JVM的外部实现。对于任意的一个类，都必须由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性。JVM提供中类加载器。</p><h2 id="二、启动类加载器-bootstrap-classloader" tabindex="-1">二、启动类加载器（Bootstrap ClassLoader） <a class="header-anchor" href="#二、启动类加载器-bootstrap-classloader" aria-label="Permalink to &quot;二、启动类加载器（Bootstrap ClassLoader）&quot;">​</a></h2><p>负责加载 JAVA_HOME\\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被 虚拟机认可（按文件名识别，如 rt.jar）的类。</p><p><img src="https://img.springlearn.cn/blog/learn_1589811324000.png" alt=""></p><h2 id="三、扩展类加载器-extension-classloader" tabindex="-1">三、扩展类加载器(Extension ClassLoader) <a class="header-anchor" href="#三、扩展类加载器-extension-classloader" aria-label="Permalink to &quot;三、扩展类加载器(Extension ClassLoader)&quot;">​</a></h2><p>负责加载 JAVA_HOME\\lib\\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类 库。</p><p><img src="https://img.springlearn.cn/blog/learn_1589811366000.png" alt=""></p><h2 id="四、应用程序类加载器-application-classloader" tabindex="-1">四、应用程序类加载器(Application ClassLoader) <a class="header-anchor" href="#四、应用程序类加载器-application-classloader" aria-label="Permalink to &quot;四、应用程序类加载器(Application ClassLoader)&quot;">​</a></h2><p>负责加载用户路径（classpath）上的类库。 JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader 实现自定义的类加载器。</p><p><img src="https://img.springlearn.cn/blog/learn_1589811400000.png" alt=""></p><h2 id="五、原理解释" tabindex="-1">五、原理解释 <a class="header-anchor" href="#五、原理解释" aria-label="Permalink to &quot;五、原理解释&quot;">​</a></h2><p>ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</p><h2 id="六、为什么要使用双亲委托这种模型呢" tabindex="-1">六、为什么要使用双亲委托这种模型呢？ <a class="header-anchor" href="#六、为什么要使用双亲委托这种模型呢" aria-label="Permalink to &quot;六、为什么要使用双亲委托这种模型呢？&quot;">​</a></h2><p>因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。</p><h2 id="七、但是jvm在搜索类的时候-又是如何判定两个class是相同的呢" tabindex="-1">七、但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？ <a class="header-anchor" href="#七、但是jvm在搜索类的时候-又是如何判定两个class是相同的呢" aria-label="Permalink to &quot;七、但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？&quot;">​</a></h2><p>JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span> /**</span></span>
<span class="line"><span>         * rt目录:</span></span>
<span class="line"><span>         * 加载rt.jar的类加载器</span></span>
<span class="line"><span>         */</span></span>
<span class="line"><span>        ClassLoader rtClassLoader = StringBuffer.class.getClassLoader();</span></span>
<span class="line"><span>        System.out.println(rtClassLoader);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        /**</span></span>
<span class="line"><span>         * lib/ext扩展包</span></span>
<span class="line"><span>         * sun.misc.Launcher$ExtClassLoader@67b6d4ae</span></span>
<span class="line"><span>         */</span></span>
<span class="line"><span>        ClassLoader extClassLoader = EventID.class.getClassLoader();</span></span>
<span class="line"><span>        System.out.println(extClassLoader);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        /**</span></span>
<span class="line"><span>         * 当前应用加载器</span></span>
<span class="line"><span>         * sun.misc.Launcher$AppClassLoader@33909752</span></span>
<span class="line"><span>         */</span></span>
<span class="line"><span>        ClassLoader classLoader = BaseSyntaxTest.class.getClassLoader();</span></span>
<span class="line"><span>        System.out.println(classLoader);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        /**</span></span>
<span class="line"><span>         * sun.misc.Launcher$AppClassLoader@33909752</span></span>
<span class="line"><span>         */</span></span>
<span class="line"><span>        ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();</span></span>
<span class="line"><span>        System.out.println(currentClassLoader);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>最后求关注,求订阅,谢谢你的阅读!</p><p><img src="https://img.springlearn.cn/blog/learn_1589360371000.png" alt=""></p>`,24)]))}const m=s(p,[["render",r]]);export{u as __pageData,m as default};
