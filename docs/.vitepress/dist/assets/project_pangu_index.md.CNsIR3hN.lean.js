import{_ as p,C as r,c as i,aa as s,m as l,a,H as t,w as o,o as c}from"./chunks/framework.swcE7GHT.js";const f=JSON.parse('{"title":"SpringBoot脚手架【web版本】","description":"","frontmatter":{"breadcrumb":false,"navbar":true,"sidebar":true,"pageInfo":true,"contributor":true,"editLink":true,"updateTime":true,"prev":true,"next":true,"comment":true,"footer":true,"backtotop":true,"title":"SpringBoot脚手架【web版本】"},"headers":[],"relativePath":"project/pangu/index.md","filePath":"project/pangu/index.md"}'),u={name:"project/pangu/index.md"};function b(d,n,m,g,h,v){const e=r("groupId");return c(),i("div",null,[n[3]||(n[3]=s('<p><img src="https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png" alt=""></p><p><strong>公众号</strong>: 西魏陶渊明<br><strong>CSDN</strong>: <a href="https://springlearn.blog.csdn.net/?type=blog" target="_blank" rel="noreferrer">https://springlearn.blog.csdn.net</a><br></p><blockquote><p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p></blockquote><p><img src="https://img.springlearn.cn/blog/8f3392b9badb093f9e1a6472b4a98487.gif" alt=""></p><p><a href="https://github.com/lxchinesszz/pangu-plus" target="_blank" rel="noreferrer">Gitbub</a></p><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><h3 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h3><p>现状1: 乱 同部门项目结构定义各自为战, 没有一个标准化的项目结构 现状2: 繁 项目定义没有技术难度，且都是这种重复工作劳动, 感觉繁不胜繁</p><p>“删繁就简三秋树，领异标新二月花。” 删繁就简，开辟新路</p><h3 id="价值" tabindex="-1">价值 <a class="header-anchor" href="#价值" aria-label="Permalink to &quot;价值&quot;">​</a></h3><p>提高生产效率 &amp; 统一标准规范 &amp; 基于标准规范提供通用能力 &amp; 提高影响力</p><p><img src="https://img.springlearn.cn/blog/8a43d49b4e8c81c73d781ba427d23179.png" alt=""></p><h2 id="一、spring的设计思路" tabindex="-1">一、Spring的设计思路 <a class="header-anchor" href="#一、spring的设计思路" aria-label="Permalink to &quot;一、Spring的设计思路&quot;">​</a></h2><h3 id="_1-1-自动装箱" tabindex="-1">1.1 自动装箱 <a class="header-anchor" href="#_1-1-自动装箱" aria-label="Permalink to &quot;1.1 自动装箱&quot;">​</a></h3>',14)),l("p",null,[n[1]||(n[1]=a("只需要引入")),t(e,null,{default:o(()=>n[0]||(n[0]=[a("io.spring.initializr")])),_:1}),n[2]||(n[2]=a("相关配置，就具备的脚手架的能力。看起来挺简单的。 但是, 等等。Spring只提供单一模块的脚手架应用, 这显然不服务我们实际生产的项目结构。要深度定制化开发才能符合我们项目生产结构。 既然如此我们为啥还要用Spring的框架呢? 两个原因。"))]),n[4]||(n[4]=s(`<ol><li>Spring脚手架提供了一个标准的api, 没办法,先入为主，除非美国说要制裁我们。</li><li>Spring的模板的操作提供了面向对象的编程方式，比如我们修改Maven的POM和依赖的信息, 都有面向对象的API方式调用。</li></ol><h2 id="二、-一个实际的构建流程是什么样的" tabindex="-1">二、 一个实际的构建流程是什么样的? <a class="header-anchor" href="#二、-一个实际的构建流程是什么样的" aria-label="Permalink to &quot;二、 一个实际的构建流程是什么样的?&quot;">​</a></h2><p><a href="https://start.spring.io/starter.zip?type=maven-project%5C&amp;language=java%5C&amp;bootVersion=2.5.2.RELEASE%5C&amp;baseDir=demo%5C&amp;groupId=com.example%5C&amp;artifactId=demo%5C&amp;name=demo%5C&amp;description=Demo%20project%20for%20Spring%20Boot%5C&amp;packageName=com.example.demo%5C&amp;packaging=jar%5C&amp;javaVersion=11%5C&amp;dependencies=session" target="_blank" rel="noreferrer">https://start.spring.io/starter.zip?type=maven-project\\&amp;language=java\\&amp;bootVersion=2.5.2.RELEASE\\&amp;baseDir=demo\\&amp;groupId=com.example\\&amp;artifactId=demo\\&amp;name=demo\\&amp;description=Demo project for Spring Boot\\&amp;packageName=com.example.demo\\&amp;packaging=jar\\&amp;javaVersion=11\\&amp;dependencies=session</a></p><p>依赖中只引入了一个Session。</p><h3 id="_2-1-构建的原信息来自哪里" tabindex="-1">2.1 构建的原信息来自哪里 <a class="header-anchor" href="#_2-1-构建的原信息来自哪里" aria-label="Permalink to &quot;2.1 构建的原信息来自哪里&quot;">​</a></h3><p>先回答问题,来自于application.yml。这里你可以配置要支持的java版本, Language类型等等 简单点你在页面看到的都是配置的。</p><h3 id="_2-2-spring如何接受到信息" tabindex="-1">2.2 Spring如何接受到信息 <a class="header-anchor" href="#_2-2-spring如何接受到信息" aria-label="Permalink to &quot;2.2 Spring如何接受到信息&quot;">​</a></h3><p>Spring提供了一个抽象接口, 和一个限定反省类。<code>ProjectRequest </code> 。 没错你想的没错，页面看到的配置信息都在ProjectRequest 有对应的字段来接受。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public abstract class ProjectGenerationController&lt;R extends ProjectRequest&gt;{}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>实现抽象类，然后注册成一个Bean。 那么就会自动的替换了系统本来已经提供的默认实现。实现原理就是@ConditionalOnMissingBean</p><h3 id="_2-3-配置信息如何最终被解析" tabindex="-1">2.3 配置信息如何最终被解析 <a class="header-anchor" href="#_2-3-配置信息如何最终被解析" aria-label="Permalink to &quot;2.3 配置信息如何最终被解析&quot;">​</a></h3><p>前面的请求最中会被转发到 ProjectGenerationInvoker 来代为处理，简单来说就是我们的业务Service。 关键类来了，请注意: ProjectDescription。 这个类会被全局使用, 包含了项目创建的所有信息,包括依赖信息等。那这个时候问题就来了，前端关于依赖只传了一个session, 我们是如何知道这个session所对应的groupId等坐标信息的呢? 看这里 ProjectRequestToDescriptionConverter, 废话不多数，直接看代码。主要观察注释。自己思考。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 一个请求信息, 一个metadata，这一看就是所有的配置信息</span></span>
<span class="line"><span>public void convert(ProjectRequest request, MutableProjectDescription description, InitializrMetadata metadata) {</span></span>
<span class="line"><span>   validate(request, metadata);</span></span>
<span class="line"><span>   Version platformVersion = getPlatformVersion(request, metadata);</span></span>
<span class="line"><span>   // 根据请求信息去搜索依赖，根据id-&gt;session 就找到 这个session所对应的坐标。</span></span>
<span class="line"><span>   List&lt;Dependency&gt; resolvedDependencies = getResolvedDependencies(request, platformVersion, metadata);</span></span>
<span class="line"><span>   validateDependencyRange(platformVersion, resolvedDependencies);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   description.setApplicationName(request.getApplicationName());</span></span>
<span class="line"><span>   description.setArtifactId(request.getArtifactId());</span></span>
<span class="line"><span>   ...</span></span>
<span class="line"><span>   resolvedDependencies.forEach((dependency) -&gt; description.addDependency(dependency.getId(),</span></span>
<span class="line"><span>         MetadataBuildItemMapper.toDependency(dependency)));</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_2-4-如果构建maven的模块呢" tabindex="-1">2.4 如果构建Maven的模块呢? <a class="header-anchor" href="#_2-4-如果构建maven的模块呢" aria-label="Permalink to &quot;2.4 如果构建Maven的模块呢?&quot;">​</a></h3><p><code>ProjectAssetGenerator&lt;T&gt; projectAssetGenerator</code>。经过重重的信息添加, 最终到这里了，这里是我们要进行二次开发的严重地区。</p><h4 id="_2-4-1-先看下原始代码" tabindex="-1">2.4.1 先看下原始代码 <a class="header-anchor" href="#_2-4-1-先看下原始代码" aria-label="Permalink to &quot;2.4.1 先看下原始代码&quot;">​</a></h4><p>这里会构建一个单一的模块信息, 这里大家有没有发现点什么?</p><ul><li>ProjectDescription 怎么变成了一个Bean ？</li><li>ProjectContributor 也是一个Bean？</li><li>系统提供了那些ProjectContributor，都是干什么的? 后面我们要基于这个扩展</li></ul><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>  public Path generate(ProjectGenerationContext context) throws IOException {</span></span>
<span class="line"><span>      ProjectDescription description = context.getBean(ProjectDescription.class);</span></span>
<span class="line"><span>      Path projectRoot = resolveProjectDirectoryFactory(context).createProjectDirectory(description);</span></span>
<span class="line"><span>      Path projectDirectory = initializerProjectDirectory(projectRoot, description);</span></span>
<span class="line"><span>      List&lt;ProjectContributor&gt; contributors = context.getBeanProvider(ProjectContributor.class).orderedStream()</span></span>
<span class="line"><span>      .collect(Collectors.toList());</span></span>
<span class="line"><span>      for (ProjectContributor contributor : contributors) {</span></span>
<span class="line"><span>      contributor.contribute(projectDirectory);</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      return projectRoot;</span></span>
<span class="line"><span>  }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>问题解答:</p><ol><li>ProjectDescription 怎么变成了一个Bean Spring会基于每次的请求,生成ProjectDescription。同时将其注册成为一个Bean。(可以自己去找)</li><li>ProjectContributor 也是一个Bean？ ProjectContributor是提供的一个扩展点, 只有一个方法就是一个目录文件, 由上代码可知,这个目录就是项目目录。 Eg: ascm目录。 (所以如果我们要扩展这里就不能在用根目录了)</li></ol><p><code>void contribute(Path projectRoot) throws IOException;</code></p><ol start="3"><li>系统提供了那些ProjectContributor。</li><li>MainSourceCodeCustomizer 看名字就是生成Spring引导类的扩展</li><li>TestSourceCodeProjectContributor 看名字就是生成Spring测试引导类的扩展</li><li>WebFoldersContributor 看名字就是生成web相关目录, 如果发现依赖中有web就...</li><li>ApplicationPropertiesContributor 看名字就是生成配置文件</li><li>HelpDocumentProjectContributor 看名字就是生成帮助文档</li><li>MavenBuildProjectContributor 看名字好像看不出来，其实就是生成pom文件</li><li>MavenWrapperContributor 看名字好像也看不出来，其实就是生成mvnw.cmd 这个没用的东西</li><li>GitIgnoreContributor 看名字 就是生成忽略的目录</li></ol><p>不展开了，代码非常简单。（这句话你别信, 流程很简单，但是细节很丰富, 字越少事越大）</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 流程代码, 可以看到就是实现了MainSourceCodeCustomizer。就是填充启动类代码的代码。</span></span>
<span class="line"><span>class ServletInitializerContributor implements</span></span>
<span class="line"><span>      MainSourceCodeCustomizer&lt;TypeDeclaration, CompilationUnit&lt;TypeDeclaration&gt;, SourceCode&lt;TypeDeclaration, CompilationUnit&lt;TypeDeclaration&gt;&gt;&gt; {</span></span>
<span class="line"><span></span></span>
<span class="line"><span> </span></span>
<span class="line"><span>   @Override</span></span>
<span class="line"><span>   public void customize(SourceCode&lt;TypeDeclaration, CompilationUnit&lt;TypeDeclaration&gt;&gt; sourceCode) {</span></span>
<span class="line"><span>      CompilationUnit&lt;TypeDeclaration&gt; compilationUnit = sourceCode.createCompilationUnit(this.packageName,</span></span>
<span class="line"><span>            &quot;ServletInitializer&quot;);</span></span>
<span class="line"><span>      TypeDeclaration servletInitializer = compilationUnit.createTypeDeclaration(&quot;ServletInitializer&quot;);</span></span>
<span class="line"><span>      servletInitializer.extend(this.initializerClassName);</span></span>
<span class="line"><span>      customizeServletInitializer(servletInitializer);</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   @SuppressWarnings(&quot;unchecked&quot;)</span></span>
<span class="line"><span>   private void customizeServletInitializer(TypeDeclaration servletInitializer) {</span></span>
<span class="line"><span>      List&lt;ServletInitializerCustomizer&lt;?&gt;&gt; customizers = this.servletInitializerCustomizers.orderedStream()</span></span>
<span class="line"><span>            .collect(Collectors.toList());</span></span>
<span class="line"><span>      LambdaSafe.callbacks(ServletInitializerCustomizer.class, customizers, servletInitializer)</span></span>
<span class="line"><span>            .invoke((customizer) -&gt; customizer.customize(servletInitializer));</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>细节代码，可以看到是面向对象的编程方式。我们不需要使用模板来自己写了。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>@Bean</span></span>
<span class="line"><span>ServletInitializerCustomizer&lt;JavaTypeDeclaration&gt; javaServletInitializerCustomizer(</span></span>
<span class="line"><span>      ProjectDescription description) {</span></span>
<span class="line"><span>   return (typeDeclaration) -&gt; {</span></span>
<span class="line"><span>      typeDeclaration.modifiers(Modifier.PUBLIC);</span></span>
<span class="line"><span>      JavaMethodDeclaration configure = JavaMethodDeclaration.method(&quot;configure&quot;)</span></span>
<span class="line"><span>            .modifiers(Modifier.PROTECTED)</span></span>
<span class="line"><span>            .returning(&quot;org.springframework.boot.builder.SpringApplicationBuilder&quot;)</span></span>
<span class="line"><span>            .parameters(new Parameter(&quot;org.springframework.boot.builder.SpringApplicationBuilder&quot;,</span></span>
<span class="line"><span>                  &quot;application&quot;))</span></span>
<span class="line"><span>            .body(new JavaReturnStatement(new JavaMethodInvocation(&quot;application&quot;, &quot;sources&quot;,</span></span>
<span class="line"><span>                  description.getApplicationName() + &quot;.class&quot;)));</span></span>
<span class="line"><span>      configure.annotate(Annotation.name(&quot;java.lang.Override&quot;));</span></span>
<span class="line"><span>      typeDeclaration.addMethodDeclaration(configure);</span></span>
<span class="line"><span>   };</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>但是从中我们学习到的知识是，对于多模块核心模块我们会使用到</p><ul><li>MainSourceCodeCustomizer 看名字就是生成Spring引导类的扩展</li><li>TestSourceCodeProjectContributor 看名字就是生成Spring测试引导类的扩展</li><li>WebFoldersContributor 看名字就是生成web相关目录, 如果发现依赖中有web就...</li><li>ApplicationPropertiesContributor 看名字就是生成配置文件 对于父目录</li><li>HelpDocumentProjectContributor 这里要替换成我们自己的模板要进行二次开发</li><li>MavenBuildProjectContributor 二次开发，不能用系统提供的Maven信息., 因为系统提供的是单模块的pom</li><li>MavenWrapperContributor 感觉没啥用</li><li>GitIgnoreContributor 改动比较小，不改也没关系</li></ul><h4 id="_2-4-2-改动后的代码-支持多模块" tabindex="-1">2.4.2 改动后的代码，支持多模块 <a class="header-anchor" href="#_2-4-2-改动后的代码-支持多模块" aria-label="Permalink to &quot;2.4.2 改动后的代码，支持多模块&quot;">​</a></h4><p>MavenModuleFactory 将单一模块转换成多模块，并为每个模块生成一个执行方法。 其实就是将原来的代码, 封装到每个Module里面，然后填充上自己的扩展信息。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public Path generate(ProjectGenerationContext context) throws IOException {</span></span>
<span class="line"><span>    ProjectDescription description = context.getBean(ProjectDescription.class);</span></span>
<span class="line"><span>    Path projectRoot = resolveProjectDirectoryFactory(context).createProjectDirectory(description);</span></span>
<span class="line"><span>    // 1. 先创建项目根目录</span></span>
<span class="line"><span>    Path projectDirectory = initializerProjectDirectory(projectRoot, description);</span></span>
<span class="line"><span>    // 2. 构建依赖关系</span></span>
<span class="line"><span>    MavenModuleFactory mavenModuleFactory = new MavenModuleFactory(context, projectDirectory);</span></span>
<span class="line"><span>    List&lt;ModuleGeneratorExecute&gt; modules = mavenModuleFactory.getModule();</span></span>
<span class="line"><span>    for (ModuleGeneratorExecute module : modules) {</span></span>
<span class="line"><span>        module.generator();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return projectRoot;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>抽象出多模块的实体。</p><p><img src="https://img.springlearn.cn/blog/45de2b1a0567e0f3a5c6aa872544a773.png" alt=""></p><p>Module和Module是关联关系, 所以看到Module和AbstractModuleTemplate直接由一个组合的虚线关系。</p><p><img src="https://img.springlearn.cn/blog/3df53e4f6f20506c089010a357dc17ac.png" alt=""></p><h3 id="_2-5-文件生成" tabindex="-1">2.5 文件生成 <a class="header-anchor" href="#_2-5-文件生成" aria-label="Permalink to &quot;2.5 文件生成&quot;">​</a></h3><p>到这里文件已经生成了，已经在服务端生成了一个具有Maven结构的项目。但这个时候他是在服务起的 某个随机的目录下面的，就需要在将其转换成二进制数据, 传给前端。到此流程结束。</p><h2 id="三、二次开发提供的扩展点" tabindex="-1">三、二次开发提供的扩展点 <a class="header-anchor" href="#三、二次开发提供的扩展点" aria-label="Permalink to &quot;三、二次开发提供的扩展点&quot;">​</a></h2><h3 id="_3-1-为某个模块定制pom信息。" tabindex="-1">3.1 为某个模块定制POM信息。 <a class="header-anchor" href="#_3-1-为某个模块定制pom信息。" aria-label="Permalink to &quot;3.1 为某个模块定制POM信息。&quot;">​</a></h3><p>将用户选择的的依赖信息, 转移到具体某个Module上。具体要转移什么由你决定。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public interface MavenModuleBuildCustomizer {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 初始时候,moduleMavenBuild是没有任何信息的,需要开发者</span></span>
<span class="line"><span>     * 自定义的将parentMavenBuild的信息,同步到parentMavenBuild</span></span>
<span class="line"><span>     *</span></span>
<span class="line"><span>     * @param parentMavenBuild 全局的maven配置信息</span></span>
<span class="line"><span>     * @param moduleMavenBuild 每个module配置</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    void customize(MavenBuild parentMavenBuild, MavenBuild moduleMavenBuild);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_3-2-为某个模块创建目录" tabindex="-1">3.2 为某个模块创建目录 <a class="header-anchor" href="#_3-2-为某个模块创建目录" aria-label="Permalink to &quot;3.2 为某个模块创建目录&quot;">​</a></h3><p>可以参考 <code>MainSourceCodeCustomizer </code> 的实现方案，如果用面向对象的方式生成代码，也可以参照 GitIgnoreContributor的方式, 直接通过模板文件来生成文件。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public interface ProjectContributor extends Ordered {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   /**</span></span>
<span class="line"><span>    * Contribute additional resources to the project in the specified root directory.</span></span>
<span class="line"><span>    * @param projectRoot the root directory of the project</span></span>
<span class="line"><span>    * @throws IOException if contributing a resource failed</span></span>
<span class="line"><span>    */</span></span>
<span class="line"><span>   void contribute(Path projectRoot) throws IOException;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   @Override</span></span>
<span class="line"><span>   default int getOrder() {</span></span>
<span class="line"><span>      return 0;</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="四、前端定制" tabindex="-1">四、前端定制 <a class="header-anchor" href="#四、前端定制" aria-label="Permalink to &quot;四、前端定制&quot;">​</a></h2><p><img src="https://img.springlearn.cn/blog/49e9c4466a948891f6bc24d1909ce05d.png" alt=""></p><h3 id="_4-1-原数据信息" tabindex="-1">4.1 原数据信息 <a class="header-anchor" href="#_4-1-原数据信息" aria-label="Permalink to &quot;4.1 原数据信息&quot;">​</a></h3><ul><li>Spring的版本信息和依赖等相关信息, 可以通过配置方式来解决</li><li>代码配置，供应链可以共建, 需要自己去开发需要往每个模块要写的内容。</li></ul><h2 id="五、扩展点" tabindex="-1">五、扩展点 <a class="header-anchor" href="#五、扩展点" aria-label="Permalink to &quot;五、扩展点&quot;">​</a></h2><p>对Module进行扩展,可以往Module的pom文件中添加信息 <img src="https://img.springlearn.cn/blog/26ea572ed526229b3c14b73f6ffc7343.png" alt=""> 对Module进行扩展,可以向指定的包中添加信息</p><p><img src="https://img.springlearn.cn/blog/f44e44f2678ec2e5745996ee8691b794.png" alt=""></p>`,52))])}const P=p(u,[["render",b]]);export{f as __pageData,P as default};
