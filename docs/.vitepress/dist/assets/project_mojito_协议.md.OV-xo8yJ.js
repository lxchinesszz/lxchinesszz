import{_ as o,c as t,aa as a,o as r}from"./chunks/framework.CC62xl_U.js";const u=JSON.parse('{"title":"Protocol协议篇设计思路","description":"","frontmatter":{"breadcrumb":false,"navbar":true,"sidebar":true,"pageInfo":true,"contributor":true,"editLink":true,"updateTime":true,"prev":true,"next":true,"comment":true,"footer":true,"backtotop":true,"title":"Protocol协议篇设计思路","category":"Mojito"},"headers":[],"relativePath":"project/mojito/协议.md","filePath":"project/mojito/协议.md"}'),c={name:"project/mojito/协议.md"};function l(i,e,n,d,p,s){return r(),t("div",null,e[0]||(e[0]=[a('<h1 id="protocol协议篇设计思路" tabindex="-1">Protocol协议篇设计思路 <a class="header-anchor" href="#protocol协议篇设计思路" aria-label="Permalink to &quot;Protocol协议篇设计思路&quot;">​</a></h1><h2 id="一、概述" tabindex="-1">一、概述 <a class="header-anchor" href="#一、概述" aria-label="Permalink to &quot;一、概述&quot;">​</a></h2><p>协议即约定,最简单理解就是服务端按照什么样的规则来解析TCP通道传输来的二进制数据。</p><p>框架中协议提供了HTTP/HTTPS/MOJITO三种。其中HTTP/HTTPS准确来说其实就是一种,标准的HTTP协议。如果采用HTTP协议的话，不仅可以使用框架生成的Client同时也可以使用 市面上任何的HttpClient框架。</p><p>eg:</p><ul><li>OkHttp</li><li>HttpClient</li><li>Unirest</li></ul><h2 id="二、设计" tabindex="-1">二、设计 <a class="header-anchor" href="#二、设计" aria-label="Permalink to &quot;二、设计&quot;">​</a></h2><p>框架中协议的接口类是 <code>Protocol&lt;R extends RpcProtocolHeader, V extends RpcProtocolHeader&gt; </code>。</p><ul><li>泛型 <code>R</code> 为请求数据模型</li><li>泛型 <code>V</code> 为响应数据模型</li></ul><p><code>Protocol</code> 是一个比较核心的类贯穿始终。因为核心的组件都放在了 <code>Protocol</code> 类中，这样的设计目的是为了让框架看起来简单。主要的思想借鉴与 <code>Mybatis</code> 中的 <code>Configuration </code> 所有的核心配置都放在其中，让人一看便懂,快速了解架构,进行二次开发。</p><p><img src="https://img.springlearn.cn/blog/learn_1600953756000.png" alt=""></p><h3 id="_1-通道编码器" tabindex="-1">1. 通道编码器 <a class="header-anchor" href="#_1-通道编码器" aria-label="Permalink to &quot;1. 通道编码器&quot;">​</a></h3><p>面向TCP编程,网络中数据都是二进制数据。客户端会将Java数据模型,按照一定的格式转换成二进制数据经过TCP协议传输给服务端。</p><h3 id="_2-通道解码器" tabindex="-1">2. 通道解码器 <a class="header-anchor" href="#_2-通道解码器" aria-label="Permalink to &quot;2. 通道解码器&quot;">​</a></h3><p>服务端根据约定的格式(可以理解这个约定就是协议),通过通道解码器将二进制数据重新转换成Java数据模型。</p><h3 id="_3-api交换器" tabindex="-1">3. API交换器 <a class="header-anchor" href="#_3-api交换器" aria-label="Permalink to &quot;3. API交换器&quot;">​</a></h3><p>框架底层是基于 <code>Netty</code> 进行开发, <code>ExchangeChannelHandler</code> 负责将 <code>Netty</code> 的 <code>API</code> 转换成框架 <code>API</code> ,目的是对原生 <code>Netty</code> 的网络通道 <code>Channel</code> 进行增强。同时降低学习成本。</p><h3 id="_4-服务端处理器" tabindex="-1">4. 服务端处理器 <a class="header-anchor" href="#_4-服务端处理器" aria-label="Permalink to &quot;4. 服务端处理器&quot;">​</a></h3><p>服务端是对客户端传来的数据进行处理的, 这里是由开发者来编程的业务处理器。</p><h3 id="_5-客户端处理器" tabindex="-1">5. 客户端处理器 <a class="header-anchor" href="#_5-客户端处理器" aria-label="Permalink to &quot;5. 客户端处理器&quot;">​</a></h3><p>通信的连接默认都是长连接，如何处理长连接中数据交互所对应的关系，主要就是在这里实现的,框架内置处理器。在发送数据时候会在本地保存一个发送的唯一码，服务端响应时候会告诉我们 对应的唯一码，从而完成异步通知。</p><p><strong>长连接通道中会有很多数据包在其中传输,如果不给每个数据包一个唯一的标志，那么客户端在接受到服务端的响应时候就不知道对应的是那个发送请求。</strong></p><p><img src="https://img.springlearn.cn/blog/learn_1600954759000.png" alt=""></p><p><strong>解决办法: 给每个数据包加上唯一的标识头，当客户端收到服务端响应时候就知道是对应的那个请求了</strong></p><p><img src="https://img.springlearn.cn/blog/learn_1600954859000.png" alt=""></p><p>这个标志头在框架中就是 <code>RpcProtocolHeader</code>。 其组成部分: 协议类型(byte) + 序列化类型(byte) + 请求类型(byte) + id(String)</p>',26)]))}const P=o(c,[["render",l]]);export{u as __pageData,P as default};
