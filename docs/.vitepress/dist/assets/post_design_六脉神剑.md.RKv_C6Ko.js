import{_ as i,c as a,aa as n,o as p}from"./chunks/framework.FHBy0zsw.js";const k=JSON.parse('{"title":"六大原则 & 23种设计模式","description":"","frontmatter":{"breadcrumb":false,"navbar":true,"sidebar":true,"pageInfo":true,"contributor":true,"editLink":true,"updateTime":true,"prev":true,"next":true,"comment":true,"time":"2022-05-24T00:00:00.000Z","footer":true,"backtotop":true,"title":"六大原则 & 23种设计模式","sticky":true,"word":true,"category":"设计&规范","star":true,"original":true,"image":"https://img.springlearn.cn/blog/learn_1653399918000.png"},"headers":[],"relativePath":"post/design/六脉神剑.md","filePath":"post/design/六脉神剑.md"}'),t={name:"post/design/六脉神剑.md"};function e(l,s,r,o,h,g){return p(),a("div",null,s[0]||(s[0]=[n(`<p><img src="https://img.springlearn.cn/blog/learn_1653399918000.png" alt=""></p><h2 id="一、设计模式" tabindex="-1">一、设计模式 <a class="header-anchor" href="#一、设计模式" aria-label="Permalink to &quot;一、设计模式&quot;">​</a></h2><p>设计模式一般分为三类：创建型模式、结构型模式、行为型模式。</p><ul><li>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。</li><li>结构型模式：把类或对象结合在一起形成一个更大的结构。</li><li>行为型模式：类和对象如何交互，及划分责任和算法</li></ul><p><img src="https://img.springlearn.cn/27c9d5187cd283f8d160ec1ed2b5ac89.jpg" alt=""></p><h2 id="_1-1-创建型模式" tabindex="-1">1.1 创建型模式 <a class="header-anchor" href="#_1-1-创建型模式" aria-label="Permalink to &quot;1.1 创建型模式&quot;">​</a></h2><p>创建型模式简单来说就是用来创建对象的。一共有五种：单例模式、建造者模式、工厂方法模式、抽象工厂模式、原型模式。</p><ol><li>单例模式 ：确保某一个类只有一个实例，并且提供一个全局访问点。</li><li>建造者模式 ： 用来创建复杂的复合对象。</li><li>工厂方法模式 ：让子类来决定要创建哪个对象。</li><li>抽象工厂模式 ：创建多个产品族中的产品对象。</li><li>原型模式 ：通过复制原型来创建新对象。</li></ol><h2 id="_1-2-结构型模式" tabindex="-1">1.2 结构型模式 <a class="header-anchor" href="#_1-2-结构型模式" aria-label="Permalink to &quot;1.2 结构型模式&quot;">​</a></h2><p>结构型模式主要是用于处理类或者对象的组合。一共有七种：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><ol><li>代理模式 ：控制客户端对对象的访问。</li><li>组合模式 ：将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理。</li><li>适配器模式 ：将原来不兼容的两个类融合在一起。</li><li>装饰者模式 ：为对象添加新功能。</li><li>享元模式 ：使用对象池来减少重复对象的创建。</li><li>外观模式 ：对外提供一个统一的接口用来访问子系统。</li><li>桥接模式 ：将两个能够独立变化的部分分离开来。</li></ol><h2 id="_1-3-行为型模式" tabindex="-1">1.3 行为型模式 <a class="header-anchor" href="#_1-3-行为型模式" aria-label="Permalink to &quot;1.3 行为型模式&quot;">​</a></h2><p>行为型模式主要是描述类或者对象是怎样交互和怎样分配职责的。一共有十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><ol><li>策略模式 ：封装不同的算法，算法之间能互相替换。</li><li>状态模式 ：根据不同的状态做出不同的行为。</li><li>责任链模式 ：将事件沿着链去处理。</li><li>观察者模式 ：状态发生改变时通知观察者，一对多的关系。</li><li>模板方法模式 ：定义一套流程模板，根据需要实现模板中的操作。</li><li>迭代器模式 ：提供一种方法顺序访问一个聚合对象中的各个元素。</li><li>备忘录模式 ：保存对象的状态，在需要时进行恢复。</li><li>访问者模式 ：稳定数据结构中，定义新的操作行为。</li><li>中介者模式 ：将网状结构转变为星型结构，所有行为都通过中介。</li><li>解释器模式 ：定义语法，并对其进行解释。</li><li>命令模式 ：将请求封装成命令，并记录下来，能够撤销与重做。</li></ol><p><strong>总结</strong> 虽然设计模式是个好东西，能够给我们带来各种好处，比如降低对象之间的耦合，增加程序的可复用性、可扩展性、可维护性等等。 但是我们也不应该滥用设计模式，设计模式在一定程序上会增加系统的复杂性。我们在写码时应该评估好各方面，避免过度设计。</p><h2 id="二、六大原则" tabindex="-1">二、六大原则 <a class="header-anchor" href="#二、六大原则" aria-label="Permalink to &quot;二、六大原则&quot;">​</a></h2><h2 id="_2-1-开闭原则" tabindex="-1">2.1 开闭原则 <a class="header-anchor" href="#_2-1-开闭原则" aria-label="Permalink to &quot;2.1 开闭原则&quot;">​</a></h2><p><strong>定义</strong></p><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p><p><strong>问题场景</strong></p><p>在软件的生命周期内，因为变化、升级和维护等原因需要<code>对软件原有代码进行修改时</code>，可能会<code>给旧代码中引入错误</code>，也可能会使我们<code>不得不对整个功能进行重构</code>，并且需要原有代码经过重新测试。</p><p><strong>解决方案</strong></p><p>当软件需要变化时，<code>尽量通过扩展软件实体的行为来实现变化</code>，而<code>不是通过修改已有的代码</code>来实现变化。</p><p><strong>表达</strong></p><p>用抽象构建框架，用实现扩展细节因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p><p><strong>分析</strong></p><p>就是对扩展开放,对修改关闭, 里式替换原则理论支持了这个一说法,及子类要能替换父类,这样子类就可以在父类的基础上,扩展</p><h2 id="_2-2-单一职责原则" tabindex="-1">2.2 单一职责原则 <a class="header-anchor" href="#_2-2-单一职责原则" aria-label="Permalink to &quot;2.2 单一职责原则&quot;">​</a></h2><p><strong>定义</strong></p><p><code>一个类只负责一项职责。</code></p><p><strong>问题场景</strong></p><p>类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</p><p><strong>解决方案</strong></p><p>遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</p><p><strong>表达</strong></p><p>不要让责任扩散</p><p><strong>分析</strong></p><p>一个类,指责要单一,避免如果有多种职责,修改一个职责的时候,误触到其他职责的问题</p><h2 id="_2-3-里氏替换原则" tabindex="-1">2.3 里氏替换原则 <a class="header-anchor" href="#_2-3-里氏替换原则" aria-label="Permalink to &quot;2.3 里氏替换原则&quot;">​</a></h2><p><strong>定义</strong></p><p>所有引用基类的地方必须能透明地使用其子类的对象。</p><p><strong>问题场景</strong></p><p>有一功能P由类A完成，现在要扩展P,其中P由类A的子类B完成，则子类在完成的同时，可能会导致原来功能故障</p><p><strong>解决方案</strong></p><p>当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p><p><strong>表达</strong></p><p>使用继承的时候，不要随便修改父类中已经实现的方法</p><p><strong>分析</strong></p><p>子类要能替换父类</p><h2 id="_2-4-依赖倒置原则" tabindex="-1">2.4 依赖倒置原则 <a class="header-anchor" href="#_2-4-依赖倒置原则" aria-label="Permalink to &quot;2.4 依赖倒置原则&quot;">​</a></h2><p><strong>定义</strong></p><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p><p><strong>问题场景</strong></p><p>类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p><p><strong>解决方案</strong></p><p>将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p><p><strong>表达</strong></p><p>如果A依赖B，现在要改为依赖C，如果直接修改A有风险，可以让A去依赖一个接口，BC都实现这个接口，也就是策略模式</p><p><strong>分析</strong></p><p>白话就是说,要根据接口或者抽象去设计,不要依赖于细节,eg.项目中要换数据库,不用重新写底层的数据库代码. 就是使用了hibernate一样,替换方言就好了,因为hibernate是根据接口设计的,不同数据库有不同的实现,可以直接使用. eg2: 我生病了要去买药,如果A药铺,没有我就用B药铺买. 因为他们都是药铺,都有一样的功能,可以友好的替换</p><h2 id="_2-5-接口隔离原则" tabindex="-1">2.5 接口隔离原则 <a class="header-anchor" href="#_2-5-接口隔离原则" aria-label="Permalink to &quot;2.5 接口隔离原则&quot;">​</a></h2><p><strong>定义</strong></p><p>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p><p><strong>问题场景</strong></p><p>类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则<strong>类B和类D必须去实现他们不需要的方法</strong>。</p><p><strong>解决方案</strong></p><p>将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p><p><strong>表达</strong></p><p>防止去实现不需要的接口方法，可以按接口拆分，避免臃肿。</p><p><strong>分析</strong></p><p>白话,接口要最小化,功能更细分. 目的是:不需要的功能,就不要去实现</p><p>比如有些接口可能里面什么方法都没有，其存在的意义，就是为了其实现类拥有特殊的功能.所以我们也要怕我们的接口里面没有方法，就怀疑了它存在的价值</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public class RandomAccess{</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>当实现RandomAccess的类比如ArrayList就具有随机访问的能力，而没有实现该接口的，就只能去迭代访问。</p><p>我们可以简单的看下Collections下的binarySearch方法的源码</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> binarySearch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> extends Comparable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list, T key) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RandomAccess </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BINARYSEARCH_THRESHOLD)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Collections.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">indexedBinarySearch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(list, key);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Collections.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">iteratorBinarySearch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(list, key);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_2-6-迪米特法则" tabindex="-1">2.6 迪米特法则 <a class="header-anchor" href="#_2-6-迪米特法则" aria-label="Permalink to &quot;2.6 迪米特法则&quot;">​</a></h2><p><strong>定义</strong></p><p>一个对象应该对其他对象保持最少的了解。</p><p><strong>问题场景</strong></p><p>类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p><p><strong>解决方案</strong></p><p>尽量降低类与类之间的耦合。</p><p><strong>表达</strong></p><p>尽量降低类与类之间的耦合。</p><p><strong>分析</strong></p><p>降低类与类之间直接交互,能隐藏的属性就可以隐藏. eg. 修电脑,去IT部门,之前一直找小张,现在小张走了,还需要重新认识小李. 迪米特法则,就是直接找IT主管,让主管派人修. 主管就是接口，调用接口的方法，底层具体是小张还是小李，我们不用去管</p><p>这里其实也强调了接口的重要性!</p>`,88)]))}const c=i(t,[["render",e]]);export{k as __pageData,c as default};
