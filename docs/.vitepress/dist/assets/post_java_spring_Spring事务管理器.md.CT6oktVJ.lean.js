import{_ as i,o as n,c as a,a4 as e}from"./chunks/framework.B8fosacB.js";const d=JSON.parse('{"title":"Spring事务管理器Hooks","description":"","frontmatter":{"breadcrumb":false,"navbar":true,"sidebar":true,"pageInfo":true,"contributor":true,"editLink":true,"updateTime":true,"prev":true,"next":true,"comment":true,"footer":true,"backtotop":true,"title":"Spring事务管理器Hooks","category":"Spring"},"headers":[],"relativePath":"post/java/spring/Spring事务管理器.md","filePath":"post/java/spring/Spring事务管理器.md","lastUpdated":1731158524000}'),l={name:"post/java/spring/Spring事务管理器.md"};function t(p,s,r,h,o,c){return n(),a("div",{"data-pagefind-body":!0},s[0]||(s[0]=[e(`<p><img src="https://img.springlearn.cn/blog/learn_1647108921000.png" alt=""></p><p><strong>作者: 八阿哥的剑</strong></p><p><em>博客: <a href="https://springlearn.cn" target="_blank" rel="noreferrer">https://springlearn.cn</a></em></p><div class="tip custom-block"><p class="custom-block-title">一日一句毒鸡汤</p><p>问世间钱为何物，只叫人生死相许。！😄</p></div><p>写文章不容易，如果感觉还行，请点个关注，点关注不迷路。</p><h2 id="transactionsynchronizationmanager" tabindex="-1">TransactionSynchronizationManager <a class="header-anchor" href="#transactionsynchronizationmanager" aria-label="Permalink to &quot;TransactionSynchronizationManager&quot;">​</a></h2><p><code>TransactionSynchronizationManager</code> 是 Spring 框架中的一个工具类，它主要用于管理事务同步的相关内容。在 Spring 中，事务管理是通过声明式事务或者编程式事务实现的，而 <code>TransactionSynchronizationManager</code> 则是 Spring 管理事务同步时的核心组件之一。</p><p>它的主要功能包括：</p><ol><li><p><strong>绑定资源</strong>：<code>TransactionSynchronizationManager</code> 允许将资源（如数据库连接、会话等）绑定到当前线程，使得在事务过程中，这些资源可以在不同的调用方之间共享。</p></li><li><p><strong>事务同步</strong>：它管理事务的同步回调，在事务的不同阶段（如提交前、提交后、回滚时等）执行注册的回调操作。这使得你可以在事务的不同状态时执行一些自定义的操作。</p></li><li><p><strong>事务状态管理</strong>：可以检查当前线程是否有绑定的事务，或者当前事务是否只读，事务的隔离级别等。</p></li><li><p><strong>事务挂起和恢复</strong>：当嵌套事务或传播行为为“暂停当前事务”时，它可以挂起当前事务的资源并在需要时恢复它们。</p></li></ol><p>常用的方法包括：</p><ul><li><code>isSynchronizationActive()</code>：检查当前线程是否有活动的事务同步。</li><li><code>registerSynchronization(TransactionSynchronization synchronization)</code>：在当前事务上注册同步回调。</li><li><code>getResource(Object key)</code>：从当前线程获取与指定 key 绑定的资源。</li><li><code>bindResource(Object key, Object value)</code>：绑定资源到当前线程。</li><li><code>unbindResource(Object key)</code>：解除资源的绑定。</li></ul><p>这在基于 Spring 的事务管理中非常关键，因为 Spring 通过这些机制实现了高度的事务管理抽象，使开发者能更简单地处理事务。</p><h2 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h2><h3 id="事务提交后hooks" tabindex="-1">事务提交后hooks <a class="header-anchor" href="#事务提交后hooks" aria-label="Permalink to &quot;事务提交后hooks&quot;">​</a></h3><ul><li>afterCommit() <ul><li>此方法会在事务成功提交之后调用，适合进行一些依赖于事务成功的后续操作。比如在事务成功提交后，发送确认消息或者邮件通知。</li><li>注意: <ul><li>如果方法中抛出 RuntimeException，异常会被传播给调用者（注意，不要在这里抛出 TransactionException 的子类）。</li><li>事务已经提交，但事务资源可能仍然活跃且可访问。这意味着此时执行的数据访问操作仍然会参与原始事务。</li></ul></li></ul></li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 事务代码块,代码块里面的操作会放在一个单独的事务中</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FunctionalInterface</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TransactionCodeBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         * 事务动作</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> transactionAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> afterCommit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TransactionCodeBlock codeBlock) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        TransactionSynchronizationManager.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">registerSynchronization</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TransactionSynchronization</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> afterCommit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                codeBlock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transactionAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><ul><li>afterCompletion(int status) <ul><li>此方法在事务完成后调用，无论事务是提交还是回滚。通常用于清理资源，例如关闭连接或释放锁等操作。</li><li>注意同上</li></ul></li></ul>`,17)]))}const g=i(l,[["render",t]]);export{d as __pageData,g as default};
