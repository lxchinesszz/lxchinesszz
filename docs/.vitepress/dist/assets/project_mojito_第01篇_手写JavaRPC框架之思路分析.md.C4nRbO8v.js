import{_ as t,c as e,aa as r,o as p}from"./chunks/framework.swcE7GHT.js";const d=JSON.parse('{"title":"第01篇:手写JavaRPC框架之思路分析","description":"","frontmatter":{"breadcrumb":false,"navbar":true,"sidebar":true,"pageInfo":true,"contributor":true,"editLink":true,"updateTime":true,"prev":true,"next":true,"comment":true,"footer":true,"backtotop":true,"title":"第01篇:手写JavaRPC框架之思路分析","category":"Mojito"},"headers":[],"relativePath":"project/mojito/第01篇:手写JavaRPC框架之思路分析.md","filePath":"project/mojito/第01篇:手写JavaRPC框架之思路分析.md"}'),o={name:"project/mojito/第01篇:手写JavaRPC框架之思路分析.md"};function i(l,a,n,c,s,b){return p(),e("div",null,a[0]||(a[0]=[r(`<p><img src="https://img.springlearn.cn/blog/8d93a4aaf770ccc367e4bcc40513ff1b.png" alt=""></p><p><strong>作者</strong>: 西魏陶渊明</p><p><strong>博客</strong>: <a href="https://blog.springlearn.cn/" target="_blank" rel="noreferrer">https://blog.springlearn.cn/</a></p><blockquote><p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/10e3b1ba78ed2cd6afb33928df91a52f.gif" alt=""></p><h2 id="一、前言" tabindex="-1">一、前言 <a class="header-anchor" href="#一、前言" aria-label="Permalink to &quot;一、前言&quot;">​</a></h2><p>如果不是因为热爱，我不会这样；如果不是为了，涨点粉丝，我不会这样； 如果不是为了几两散碎银子，我更不会这样。</p><p>以前的文章开场太过严肃，太过专业。就像大学老师上课，只知道讲课。不知道互动。这样 效果太差，写的没意思，读者更是没意思。大数据分析还以为你是抄的，还不给你推荐热门 😭。</p><p>不然就改变一下风格吧，从本系列文章开始，小编就要放飞 ✈️ 自我，随心 ❤️ 而动。希望在分享，总结自己掌握的知识点的同时，能给各位客官带来一点小小的收获。小编尽量全力输出干货，如果看完感觉还行的话，希望能多多关注。你的关注，就是我进步的最大动力。如果看完，感觉就这? 可以留言讨论。接受各位看官的批评和意见。共同学习共同进步。</p><h2 id="二、目标" tabindex="-1">二、目标 <a class="header-anchor" href="#二、目标" aria-label="Permalink to &quot;二、目标&quot;">​</a></h2><p>本系列文章的总体目标是从零实现一个RPC框架，我们将从TCP通信协议开始， 一步一步实操，将socket 二进制数据流一步一步变成Java可以认识的数据类型， 从而最终实现RPC远程通信，并可以集成在Spring中,同时也可以支持SpringBoot的自动化配置。最终我们会将项目发布到全球Maven仓库, 让大家都可以下载学习。</p><p>本系列文章主要知识点以思维导图的方式，展示在下图=面，内容只会多不会少。干货较多，对于初级的同学可以收藏起来慢慢看。毕竟一口也吃不了一个胖子。但是不能没有信心。</p><p>正如小编的口头禅: 写代码和写文章是一样一样的。</p><p><strong>天下代码一大抄，抄来抄去有提高，看你会抄不会抄。</strong></p><p><img src="https://img.springlearn.cn/blog/7bdbd93d0e2d1b9bd0c150e119ae665a.png" alt=""></p><h2 id="三、思路分析" tabindex="-1">三、思路分析 <a class="header-anchor" href="#三、思路分析" aria-label="Permalink to &quot;三、思路分析&quot;">​</a></h2><h2 id="_3-1-什么是rpc框架" tabindex="-1">3.1 什么是RPC框架 <a class="header-anchor" href="#_3-1-什么是rpc框架" aria-label="Permalink to &quot;3.1 什么是RPC框架&quot;">​</a></h2><p>我们在要写RPC框架，我们先思考下RPC是什么? 白话点就是一个远程通信的工具而已。 他可以让开发者像调用本地方法一样，方便的调用远程的方法。</p><p>目前市面上的RPC框架主要有下面这些</p><ul><li>dubbo</li><li>grpc</li><li>feign</li></ul><p>可能对于银行和传统国企可能偏爱国产的dubbo框架，可能会涉及到国家安全吧，而对于互联网公司更多的会使用SpringCloud的全家桶。那么不管他们使用的其中的哪一款，其实这些框架都是能做到，让开发者像调用本地方法一样实现远程方法的调用的。</p><p>可以实现远程调用的呢? 答案当然就是利用socket通信了。而socket底层通信 都是基于tcp/ip协议实现的。所以以上这三款的</p><h2 id="_3-2-通信框架的区别" tabindex="-1">3.2 通信框架的区别 <a class="header-anchor" href="#_3-2-通信框架的区别" aria-label="Permalink to &quot;3.2  通信框架的区别&quot;">​</a></h2><ul><li>dubbo</li><li>grpc</li><li>feign</li></ul><p><strong>共同点:</strong></p><ul><li>都是基于tcp/ip协议来实现通信</li><li>都屏蔽底层通信细节，使开发者只用关心自己的业务即可</li></ul><p><strong>不同点:</strong></p><ul><li>grpc和feign都是基于tcp协议更上层的http协议来实现的</li><li>dubbo是基于tcp协议上自己重新实现了一套自己的规则，而这个规则就是dubbo协议。</li></ul><p>dubbo协议因为是直接基于tcp协议定制的，所以可能性能会更加的好。能实现更多的底层的特性，比如说长连接。而其他两款是基于http协议来进行封装的，正因为它的这个特性，所以只是http客户端都可以进行调用，更适合跨平台，跨语言。因为不管是什么语言，都支持http协议。但是他的性能可能就相对没有dubbo好，综上所述他们各有胜负。现在主要比的就是看谁的生态比较好，谁的周边扩展更加丰富。</p><h2 id="_3-3-rpc底层实现" tabindex="-1">3.3 RPC底层实现 <a class="header-anchor" href="#_3-3-rpc底层实现" aria-label="Permalink to &quot;3.3 RPC底层实现&quot;">​</a></h2><p>前面我们说了，RPC框架是一个，可以让程序猿像调用本地方法一样实现远程方法调用的一个工具。其实这句话就说出了主要的答案。</p><p><img src="https://img.springlearn.cn/blog/7f72d53f64e4181913a662abc2b37143.png" alt="远程调用 = 计算机通信
屏蔽细节 = 动态代理"></p><p>既然知道了他的大概实现，那么其实思路就有了。我们第一步就是使用Java语言来实现底层 的通信能力建设，然后在这个基础上进行二次封装，最终通过动态代理的形式，将底层通信的细节给屏蔽起来。如此就能实现一个RPC协议了。</p><p>思路就是这个思路。 <img src="https://img.springlearn.cn/blog/e9c48572c567ba6fdd6a5a3fbe603f24.png" alt=""></p><p>所以本系列文章的第一部分，就是先完成通信层的建设，使用Java实现一个通用的底层协议，实现通信能力。</p><p><img src="https://img.springlearn.cn/blog/07fa03c0a8f866bb365cb43e85b05317.png" alt=""></p><p>说着很简单，但是实现通信可没有那么简单哦。接下来我们面临一系列网络通信中的难题。比如说Java的通信API表难用，网络通信中还有黏包拆包等问题。但是没关系，这些坑小编已经踩过了，跟着小编的思路一步一步做。相信事半必能功倍。</p>`,37)]))}const u=t(o,[["render",i]]);export{d as __pageData,u as default};
