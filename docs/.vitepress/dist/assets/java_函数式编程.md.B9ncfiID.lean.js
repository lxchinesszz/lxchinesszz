import{_ as n,c as s,aa as e,o as t}from"./chunks/framework.swcE7GHT.js";const b=JSON.parse('{"title":"Lambda函数式编程","description":"","frontmatter":{"breadcrumb":false,"navbar":true,"pageInfo":true,"contributor":true,"editLink":true,"updateTime":true,"prev":true,"next":true,"comment":false,"footer":true,"backtotop":true,"title":"Lambda函数式编程","category":"Java进阶"},"headers":[],"relativePath":"java/函数式编程.md","filePath":"java/函数式编程.md"}'),p={name:"java/函数式编程.md"};function r(i,a,l,c,d,o){return t(),s("div",null,a[0]||(a[0]=[e(`<p><img src="https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png" alt=""></p><p><strong>作者</strong>: 西魏陶渊明 <strong>博客</strong>: <a href="https://blog.springlearn.cn/" target="_blank" rel="noreferrer">https://blog.springlearn.cn/</a></p><div class="tip custom-block"><p class="custom-block-title">西魏陶渊明</p><p>莫笑少年江湖梦，谁不少年梦江湖</p></div><blockquote><p>Java8所有的新特性基本基于函数式编程的思想，函数式编程给Java带来了注入了新鲜的活力。 函数式编程其实并不是很难，小编在学习函数式编程时候刚开始一头雾水，最后仔细观察就发现了其中的小窍门，读了本篇文章如果还没有掌握，就算我输了</p></blockquote><h1 id="函数式编程" tabindex="-1">函数式编程 <a class="header-anchor" href="#函数式编程" aria-label="Permalink to &quot;函数式编程&quot;">​</a></h1><h2 id="一、lambda表达式" tabindex="-1">一、Lambda表达式 <a class="header-anchor" href="#一、lambda表达式" aria-label="Permalink to &quot;一、Lambda表达式&quot;">​</a></h2><p><strong>注意</strong>: 以下方法都可以使用表达式来进行缩写</p><p>我们来看Java中如何来定义一个方法</p><h3 id="_1-语法" tabindex="-1">1. 语法 <a class="header-anchor" href="#_1-语法" aria-label="Permalink to &quot;1. 语法&quot;">​</a></h3><p><code>()-&gt;{}</code></p><p>其中小括号里面可以放入参，大括号就是方法体，里面也允许有返回值。</p><p><strong>当方法体中只有返回值而没有其他语句时候，大括号和 <code>return</code> 关键字都可以省略不写。</strong></p><h3 id="_2-方法引用" tabindex="-1">2. 方法引用 <a class="header-anchor" href="#_2-方法引用" aria-label="Permalink to &quot;2. 方法引用&quot;">​</a></h3><p><em>只要用.引用不报错的，都可以将.换成:</em></p><table><thead><tr><th>类型</th><th>语法</th></tr></thead><tbody><tr><td>1、引用静态方法</td><td>ClassName::staticMethodName</td></tr><tr><td>2、引用构造函数</td><td>ClassName::new</td></tr><tr><td>3、引用特定类型的实例方法</td><td>ClassName::instanceMethodName</td></tr><tr><td>4、引用特定对象的实例方法</td><td>objectName::instanceMethodName</td></tr></tbody></table><h2 id="二、java8新增函数式接口" tabindex="-1">二、Java8新增函数式接口 <a class="header-anchor" href="#二、java8新增函数式接口" aria-label="Permalink to &quot;二、Java8新增函数式接口&quot;">​</a></h2><h3 id="_1-predicate接口" tabindex="-1">1. Predicate接口 <a class="header-anchor" href="#_1-predicate接口" aria-label="Permalink to &quot;1. Predicate接口&quot;">​</a></h3><p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>根据前面的语法我们知道小括号里面可以放入参，大括号里面放出参，当大括号里面只有返回值时候，大括号和 <code>return</code> 关键字也可以省略。如上。</p><h3 id="_2-function-接口" tabindex="-1">2. Function 接口 <a class="header-anchor" href="#_2-function-接口" aria-label="Permalink to &quot;2. Function 接口&quot;">​</a></h3><p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Function&lt;Integer, Integer&gt; function = (x) -&gt; 2 * x;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>同理，这个接口有一个入参和出参，如果返回体重不包含其他逻辑，只有一个返回值，大括号和 <code>return</code> 关键字也可以省略。如上。</p><h3 id="_3-supplier-接口" tabindex="-1">3. Supplier 接口 <a class="header-anchor" href="#_3-supplier-接口" aria-label="Permalink to &quot;3. Supplier 接口&quot;">​</a></h3><p>Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public class Main{</span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>        //构造方法</span></span>
<span class="line"><span>        Supplier&lt;Main&gt; supplier = () -&gt; new Main();</span></span>
<span class="line"><span>        Supplier&lt;Main&gt; mainSupplier = Main::new;</span></span>
<span class="line"><span>        Supplier&lt;Main&gt; mainSupplier1 = Main::staticMethod;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    private static Main staticMethod() {</span></span>
<span class="line"><span>        return new Main();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>因为没有入参，所以小括号里面什么都不用写。当遇到这种情况，同样可以用上面其他两种来替换</p><h3 id="_4-consumer-接口" tabindex="-1">4. Consumer 接口 <a class="header-anchor" href="#_4-consumer-接口" aria-label="Permalink to &quot;4. Consumer 接口&quot;">​</a></h3><p>Consumer 是一个只有入参，但是无出参的接口。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public class Main {</span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>        List&lt;String&gt; dataList = Arrays.asList(&quot;1&quot;, &quot;2&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        //特定类的静态方法</span></span>
<span class="line"><span>        dataList.forEach(Main::staticMethod);</span></span>
<span class="line"><span>        dataList.forEach((x) -&gt; System.out.println(x));</span></span>
<span class="line"><span>        dataList.forEach(System.out::println);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    private static void staticMethod(String name) {</span></span>
<span class="line"><span>        System.out.println(&quot;对象静态方法引用:&quot; + name);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="三、快速记忆" tabindex="-1">三、快速记忆 <a class="header-anchor" href="#三、快速记忆" aria-label="Permalink to &quot;三、快速记忆&quot;">​</a></h2><p>虽然新增的函数式接口并不多，但是想要一次性死记住，还是有一点点的难度。小编的学习方式是 理解这记忆。</p><table><thead><tr><th>类型</th><th>简记</th></tr></thead><tbody><tr><td>1、Predicate</td><td>条件类型</td></tr><tr><td>2、Supplier</td><td>无入参，有出参</td></tr><tr><td>3、Function</td><td>有入参，有出参</td></tr><tr><td>4、Consumer</td><td>有入参，无出参</td></tr></tbody></table><p>最后求关注,求订阅,谢谢你的阅读!</p><p><img src="https://img.springlearn.cn/blog/learn_1589360371000.png" alt=""></p>`,36)]))}const h=n(p,[["render",r]]);export{b as __pageData,h as default};
