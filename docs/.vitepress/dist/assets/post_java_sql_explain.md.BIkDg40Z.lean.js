import{_ as a,o as t,c as r,a4 as i}from"./chunks/framework.B8fosacB.js";const u=JSON.parse('{"title":"explain调优","description":"","frontmatter":{"breadcrumb":false,"navbar":true,"sidebar":true,"pageInfo":true,"contributor":true,"editLink":true,"updateTime":true,"prev":true,"next":true,"comment":false,"footer":true,"backtotop":true,"title":"explain调优","category":"SQL优化"},"headers":[],"relativePath":"post/java/sql/explain.md","filePath":"post/java/sql/explain.md","lastUpdated":1731158524000}'),n={name:"post/java/sql/explain.md"};function l(o,e,s,d,p,c){return t(),r("div",{"data-pagefind-body":!0},e[0]||(e[0]=[i('<p><img src="https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png" alt=""></p><p><strong>作者</strong>: 西魏陶渊明 <strong>博客</strong>: <a href="https://blog.springlearn.cn/" target="_blank" rel="noreferrer">https://blog.springlearn.cn/</a></p><div class="tip custom-block"><p class="custom-block-title">西魏陶渊明</p><p>莫笑少年江湖梦，谁不少年梦江湖</p></div><blockquote><p>这篇文章主要讲 explain 如何使用，还有 explain 各种参数概念，之后会讲优化</p></blockquote><h1 id="一、explain-用法" tabindex="-1">一、Explain 用法 <a class="header-anchor" href="#一、explain-用法" aria-label="Permalink to &quot;一、Explain 用法&quot;">​</a></h1><p>explain模拟Mysql优化器是如何执行SQL查询语句的，从而知道Mysql是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p><p><strong>语法</strong>：<code>Explain + SQL 语句;</code></p><p>如：<code>Explain select * from user;</code> 会生成如下 SQL 分析结果，下面详细对每个字段进行详解</p><p><img src="https://img.springlearn.cn/blog/learn_1596351159000.png" alt=""></p><h2 id="_1-id" tabindex="-1">1. id <a class="header-anchor" href="#_1-id" aria-label="Permalink to &quot;1. id&quot;">​</a></h2><p>是一组数字，代表多个表之间的查询顺序，或者包含子句查询语句中的顺序，id 总共分为三种情况，依次详解</p><h3 id="id相同" tabindex="-1">id相同 <a class="header-anchor" href="#id相同" aria-label="Permalink to &quot;id相同&quot;">​</a></h3><p>id相同，执行顺序由上至下 <img src="https://img.springlearn.cn/blog/learn_1596351240000.png" alt=""></p><h3 id="id不同" tabindex="-1">id不同 <a class="header-anchor" href="#id不同" aria-label="Permalink to &quot;id不同&quot;">​</a></h3><p>id 不同，如果是子查询，id 号会递增，id 值越大优先级越高，越先被执行</p><p><img src="https://img.springlearn.cn/blog/learn_1596351303000.png" alt=""></p><h3 id="id相同和不同" tabindex="-1">id相同和不同 <a class="header-anchor" href="#id相同和不同" aria-label="Permalink to &quot;id相同和不同&quot;">​</a></h3><p>id 相同和不同的情况同时存在</p><p><img src="https://img.springlearn.cn/blog/learn_1596351331000.png" alt=""></p><h2 id="_2-select-type" tabindex="-1">2. select_type <a class="header-anchor" href="#_2-select-type" aria-label="Permalink to &quot;2. select\\_type&quot;">​</a></h2><p>select_type 包含以下几种值</p><p><code>simple</code>、<code>primary</code>、<code>subquery</code>、<code>derived</code>、<code>union</code>、<code>union result</code></p><h3 id="simple" tabindex="-1">simple <a class="header-anchor" href="#simple" aria-label="Permalink to &quot;simple&quot;">​</a></h3><p>简单的 <code>select</code> 查询，查询中不包含子查询或者 <code>union</code> 查询</p><p><img src="https://img.springlearn.cn/blog/learn_1596351522000.png" alt=""></p><h3 id="primary" tabindex="-1">primary <a class="header-anchor" href="#primary" aria-label="Permalink to &quot;primary&quot;">​</a></h3><p>如果 SQL 语句中包含任何子查询，那么子查询的最外层会被标记为 <code>primary</code></p><p><img src="https://img.springlearn.cn/blog/learn_1596351575000.png" alt=""></p><h3 id="subquery" tabindex="-1">subquery <a class="header-anchor" href="#subquery" aria-label="Permalink to &quot;subquery&quot;">​</a></h3><p>在 <code>select</code> 或者 <code>where</code> 里包含了子查询，那么子查询就会被标记为 <code>subQquery</code>，同三.二同时出现</p><p><img src="https://img.springlearn.cn/blog/learn_1596351651000.png" alt=""></p><h3 id="derived" tabindex="-1">derived <a class="header-anchor" href="#derived" aria-label="Permalink to &quot;derived&quot;">​</a></h3><p>在 <code>from</code> 中包含的一个子查询，会被标记为衍生查询，会把查询结果放到一个临时表中</p><p><img src="https://img.springlearn.cn/blog/learn_1596351720000.png" alt=""></p><h3 id="union-union-result" tabindex="-1">union / union result <a class="header-anchor" href="#union-union-result" aria-label="Permalink to &quot;union / union result&quot;">​</a></h3><p>如果有两个 <code>select</code> 查询语句，他们之间用 <code>union</code> 连起来查询，那么第二个 <code>select</code> 会被标记为 <code>union</code>，<code>union</code> 的结果被标记为 <code>union result</code>。它的 id 是为 null 的</p><p><img src="https://img.springlearn.cn/blog/learn_1596351779000.png" alt=""></p><h2 id="_3-table" tabindex="-1">3. table <a class="header-anchor" href="#_3-table" aria-label="Permalink to &quot;3. table&quot;">​</a></h2><p>表示这一行的数据是哪张表的数据</p><h2 id="_4-type" tabindex="-1">4. type <a class="header-anchor" href="#_4-type" aria-label="Permalink to &quot;4. type&quot;">​</a></h2><p>type 是代表 MySQL 使用了哪种索引类型，不同的索引类型的查询效率也是不一样的，type 大致有以下种类。 越往上性能越高。</p><table><thead><tr><th>Type类型</th><th>说明</th></tr></thead><tbody><tr><td>system</td><td>表中只有一行记录，system 是 const 的特例，几乎不会出现这种情况，可以忽略不计</td></tr><tr><td>const</td><td>必须是用主键索引或者唯一索引放到 where 条件中查询</td></tr><tr><td>eq_ref</td><td>多表查询中,索引查出来的数据都是唯一的（不能是多个,也不能是0个），常见于唯一索引和主键索引</td></tr><tr><td>ref</td><td>不是主键索引，也不是唯一索引，就是普通的索引，可能会返回多个符合条件的行。</td></tr><tr><td>range</td><td>体现在对某个索引进行区间范围检索，一般出现在 where 条件中的 between、and、&lt;、&gt;、in 等范围查找中。</td></tr><tr><td>index</td><td>将所有的索引树都遍历一遍，查找到符合条件的行。索引文件比数据文件还是要小很多，所以比不用索引全表扫描还是要快很多。</td></tr><tr><td>all</td><td>没用到索引，单纯的将表数据全部都遍历一遍，查找到符合条件的数据</td></tr></tbody></table><h2 id="_5-possible-keys" tabindex="-1">5. possible_keys <a class="header-anchor" href="#_5-possible-keys" aria-label="Permalink to &quot;5. possible\\_keys&quot;">​</a></h2><p>此次查询中涉及字段上若存在索引，则会被列出来，表示可能会用到的索引，但并不是实际上一定会用到的索引</p><h2 id="_6-key" tabindex="-1">6. key <a class="header-anchor" href="#_6-key" aria-label="Permalink to &quot;6. key&quot;">​</a></h2><p>此次查询中实际上用到的索引</p><h2 id="_7-key-len" tabindex="-1">7. key_len <a class="header-anchor" href="#_7-key-len" aria-label="Permalink to &quot;7. key\\_len&quot;">​</a></h2><p>表示索引中使用的字节数，通过该属性可以知道在查询中使用的索引长度，注意：这个长度是最大可能长度，并非实际使用长度，在不损失精确性的情况下，长度越短查询效率越高</p><h2 id="_8-ref" tabindex="-1">8. ref <a class="header-anchor" href="#_8-ref" aria-label="Permalink to &quot;8. ref&quot;">​</a></h2><p>显示关联的字段。如果使用常数等值查询，则显示 const，如果是连接查询，则会显示关联的字段。</p><p><img src="https://img.springlearn.cn/blog/learn_1596352252000.png" alt=""></p><ul><li>tb_emp 表为非唯一性索引扫描，实际使用的索引列为 idx_name，由于 tb_emp.name=&#39;rose&#39;为一个常量，所以 ref=const。</li><li>tb_dept 为唯一索引扫描，从 sql 语句可以看出，实际使用了 PRIMARY 主键索引，ref=db01.tb_emp.deptid 表示关联了 db01 数据库中 tb_emp 表的 deptid 字段。</li></ul><h2 id="_9-rows" tabindex="-1">9. rows <a class="header-anchor" href="#_9-rows" aria-label="Permalink to &quot;9. rows&quot;">​</a></h2><p>根据表信息统计以及索引的使用情况，大致估算说要找到所需记录需要读取的行数，rows 越小越好</p><h2 id="_10-extra" tabindex="-1">10. extra <a class="header-anchor" href="#_10-extra" aria-label="Permalink to &quot;10. extra&quot;">​</a></h2><p>不适合在其他列显示出来，但在优化时十分重要的信息</p><h3 id="using-filesort-重点优化" tabindex="-1">using fileSort（重点优化） <a class="header-anchor" href="#using-filesort-重点优化" aria-label="Permalink to &quot;using  fileSort（重点优化）&quot;">​</a></h3><p>俗称 &quot; 文件排序 &quot; ，在数据量大的时候几乎是“九死一生”，在 order by 或者在 group by 排序的过程中，order by 的字段不是索引字段，或者 select 查询字段存在不是索引字段，或者 select 查询字段都是索引字段，但是 order by 字段和 select 索引字段的顺序不一致，都会导致 fileSort</p><p>如果where后面的查询和order by的索引，不是一个值。就会出现fileSort。</p><p>复合索引,夸界,也会出现fileSort。</p><p>优化建议: where 什么就order by 什么。 或者 where和order by 按照复合索引顺序，不要跨列或者无序使用 <img src="https://img.springlearn.cn/blog/learn_1596352476000.png" alt=""></p><h3 id="using-temporary-重点优化" tabindex="-1">using temporary（重点优化） <a class="header-anchor" href="#using-temporary-重点优化" aria-label="Permalink to &quot;using temporary（重点优化）&quot;">​</a></h3><p>使用了临时表保存中间结果，常见于 order by 和 group by 中。</p><p>优化建议: 查询哪些列就用哪些列来order by。 能不用创建临时表就不要创建。</p><p><img src="https://img.springlearn.cn/blog/learn_1596352573000.png" alt=""></p><h3 id="using-index-重点" tabindex="-1">USING index（重点） <a class="header-anchor" href="#using-index-重点" aria-label="Permalink to &quot;USING index（重点）&quot;">​</a></h3><p>索引覆盖,就是当前sql查询不用读取原文件,只用读取索引。因为查询的列就是索引列</p><p>表示相应的 select 操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where，表面索引用来读取数据而非执行查找动作。</p><p><img src="https://img.springlearn.cn/blog/learn_1596352650000.png" alt=""></p><h3 id="using-where" tabindex="-1">Using where <a class="header-anchor" href="#using-where" aria-label="Permalink to &quot;Using where&quot;">​</a></h3><p>跟using index相反，要回表去查询。</p><p>表明使用了 where 过滤</p><h3 id="using-join-buffer" tabindex="-1">Using join buffer <a class="header-anchor" href="#using-join-buffer" aria-label="Permalink to &quot;Using join buffer&quot;">​</a></h3><p>使用了连接缓存</p><h3 id="impossible-where" tabindex="-1">impossible where <a class="header-anchor" href="#impossible-where" aria-label="Permalink to &quot;impossible where&quot;">​</a></h3><p>where 子语句的值总是 false，不能用来获取任何数据。出现这个就要检查sql。</p><p>eg: select a from test where a = 1 and a = 2。 a肯定不可能即1又是2</p><h3 id="select-tables-optimized-away" tabindex="-1">select tables optimized away <a class="header-anchor" href="#select-tables-optimized-away" aria-label="Permalink to &quot;select tables optimized away&quot;">​</a></h3><p>在没有 GROUPBY 子句的情况下，基于索引优化 MIN/MAX 操作或者 对于 MyISAM 存储引擎优化 COUNT(*)操作，不必等到执行阶段再进行计算， 查询执行计划生成的阶段即完成优化。</p><h3 id="distinct" tabindex="-1">distinct <a class="header-anchor" href="#distinct" aria-label="Permalink to &quot;distinct&quot;">​</a></h3><p>优化 distinct，在找到第一匹配的元组后即停止找同样值的工作</p>',81)]))}const b=a(n,[["render",l]]);export{u as __pageData,b as default};
